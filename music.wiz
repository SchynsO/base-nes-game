/**
 * Handle musics and notes
 */

import "nes";
import "define";

namespace music {
    
    let TEMPO = 60;
    
    // tone of square pulses
    let TONE_WEAK   = 0b00000000;
    let TONE_MID    = 0b01000000;
    let TONE_STRONG = 0b11000000;

    // set the volume to mute
    let SILENCE = 0b0000;

    let PULSE_PRESET = 0 
    | nes.apu.pulse.CONTROL_LENGTH_COUNTER_DISABLE 
    | nes.apu.pulse.CONTROL_VOLUME_CONSTANT;

    let TRIANGLE_PRESET = 0
    | nes.apu.triangle.CONTROL_LINEAR_COUNTER_ENABLE;

    let NOISE_PRESET = 0 
    | nes.apu.noise.CONTROL_LENGTH_COUNTER_DISABLE 
    | nes.apu.noise.CONTROL_VOLUME_CONSTANT;

    namespace melody {
        // special control symbols
        let MUTE = 0xFF;
        let END  = 0x00; // read end of melody on duration array

        // solfege helper
        let DO = 0; let RE = 2; let MI = 4; let FA = 5; let SOL = 7; let LA = 9; let SI = 11;
        let C  = 0; let D  = 2; let E  = 4; let F  = 5; let G   = 7; let A  = 9; let B  = 11;

        in program {
            // Au clair de la Lune
            const lune : [u8] = [
                1,DO, 1,DO, 1,DO, 1,RE, 2,MI, 2,RE,
                1,DO, 1,MI, 1,RE, 1,RE, 4,DO,
                4,MUTE, END
            ];
        }

        let OCTAVE(i) = 3 + 12 * i;
        in program {
            const pulse1 : [u8] = [
                >:&lune, <:&lune, TONE_STRONG | PULSE_PRESET | 0x8, OCTAVE(2), END
            ];
            const pulse2 : [u8] = [
                >:&lune, <:&lune, TONE_STRONG | PULSE_PRESET | 0x8, OCTAVE(3), END
            ];
            const triangle : [u8] = [
                >:&lune, <:&lune, TRIANGLE_PRESET | 1, OCTAVE(4), END
            ];
        }

    }
    
    struct Channel {
        // read and written in 'next_tempo'
        addr          : *u8, // address of the sequence
        index_melody  :  u8, // position in the composition
        index_note    :  u8, // position in the sequence
        tempo_counter :  u8, // count tempo beats

        // [write only] not read in 'next_tempo'
        period : u16, // period of the channel
        volume :  u8, // volume + controls
        octave :  u8, // set the octave to use
    }

    in zeropage {
        // addresses of the melody
        var tmp0, tmp1: u8;
        var addr0 @ &tmp0 : *u8;

        // count the length of a tempo beat
        var frame_counter : u8;

        // the three channels we can use (+ work channel)
        var work, pulse1, pulse2, triangle : Channel;
    }

    // operate on the channels in sequence
    let CHANNELS = [pulse1, pulse2, triangle];
    let MUSICS   = [melody.pulse1, melody.pulse2, melody.triangle];

    in program {

        // initialize the sound system
        func init () {
            // enable channels here
            nes.apu.enable = a = 0
            | nes.apu.ENABLE_PULSE1
            | nes.apu.ENABLE_PULSE2
            | nes.apu.ENABLE_TRIANGLE
            //| nes.apu.ENABLE_NOISE
            ;

            // initialize the channels
            a = 0;
            inline for let chl in CHANNELS {
                chl.index_melody = a;
                chl.index_note   = a;
            }
            let START_MELODIES = [melody.lune, melody.lune, melody.lune];
            inline for let i in 0 .. 2 {
                >:CHANNELS[i].addr = a = >:&START_MELODIES[i][0];
                <:CHANNELS[i].addr = a = <:&START_MELODIES[i][0];
                CHANNELS[i].volume = a = MUSICS[i][2];
                CHANNELS[i].octave = a = MUSICS[i][3];
                CHANNELS[i].tempo_counter = a = START_MELODIES[i][0];
            }
        }

        // progress over the music
        func next_frame () {
            // decrement the tempo counter until it reaches zero
            x = frame_counter;
            if {--x;} && zero {
                frame_counter = x = TEMPO;
                
                // for each of the three channels
                inline for let i in 0 .. 2 {
                    // TODO... copy its values into the work channel
                    next_tempo(work, addr0); // compute new values
                    // TODO... copy back the values into the channel
                    // TODO... apply changes
                }

            } else {frame_counter = x;}
        }

        // function to operate on a channel
        func next_tempo (channel : Channel in work, music : (*u8) in addr0) {
            // decrement the tempo counter
            x = channel.tempo_counter;
            if {--x;} && zero {
                // once it reaches zero, move on to next note
                y = channel.index_note;

                // read note duration (if zero => end)
                if {a = channel.addr[y];} && zero {

                    // move on to next melody
                    y = channel.index_melody;
                    if {a = music[y];} && zero {
                        // if we reach the end of the music, loop back
                        channel.index_melody = y = 0;
                    }

                    // write address, volume, octave
                    >:channel.addr = a = music[y]; ++y;
                    <:channel.addr = a = music[y]; ++y;
                    channel.volume = a = music[y]; ++y;
                    channel.octave = a = music[y]; ++y;
                    channel.index_melody = y;

                    // start at beginning of new melody
                    channel.index_note = y = 0;
                    a = channel.addr[y]; // read duration
                }
                // write duration of new note
                channel.tempo_counter = a; ++y;
                a = channel.addr[y]; // read pitch
                channel.index_note = ++y;

                // find the pitch of the sound to use for the new note
                y = a;
                x = a = channel.octave + music[y];
                >:channel.period = a = period.high[x];
                <:channel.period = a = period.low [x];
            
            } else {channel.tempo_counter = x;}
        }
    }

    // pitch of notes from deepest to highest
    namespace period {
        let TABLE = [
                                                                           0x7F1, 0x780, 0x713, // A1-B1  (00-02)
            0x6AD, 0x64D, 0x5F3, 0x59D, 0x54D, 0x500, 0x4B8, 0x475, 0x435, 0x3F8, 0x3BF, 0x389, // C2-B2  (03-0E)
            0x356, 0x326, 0x2F9, 0x2CE, 0x2A6, 0x27F, 0x25C, 0x23A, 0x21A, 0x1FB, 0x1DF, 0x1C4, // C3-B3  (0F-1A)
            0x1AB, 0x193, 0x17C, 0x167, 0x151, 0x13F, 0x12D, 0x11C, 0x10C, 0x0FD, 0x0EF, 0x0E2, // C4-B4  (1B-26)
            0x0D2, 0x0C9, 0x0BD, 0x0B3, 0x0A9, 0x09F, 0x096, 0x08E, 0x086, 0x07E, 0x077, 0x070, // C5-B5  (27-32)
            0x06A, 0x064, 0x05E, 0x059, 0x054, 0x04F, 0x04B, 0x046, 0x042, 0x03F, 0x03B, 0x038, // C6-B6  (33-3E)
            0x034, 0x031, 0x02F, 0x02C, 0x029, 0x027, 0x025, 0x023, 0x021, 0x01F, 0x01D, 0x01B, // C7-B7  (3F-4A)
            0x01A, 0x018, 0x017, 0x015, 0x014, 0x013, 0x012, 0x011, 0x010, 0x00F, 0x00E, 0x00D, // C8-B8  (4B-56)
            0x00C, 0x00C, 0x00B, 0x00A, 0x00A, 0x009, 0x008,                                    // C9-F#9 (57-5D)
        ];

        // period of notes splitted over two arrays
        // (It is possible to optimize high byte table since with a simple lookup table)
        /*
            if i <  3 : 0x7
            if i <  5 : 0x6
            if i <  9 : 0x5
            if i < 12 : 0x4
            if i < 17 : 0x3
            if i < 24 : 0x2
            if i < 36 : 0x1
            else 0x0
        */
        in program {
            const high : [u8] = [>:i for let i in TABLE];
            const low  : [u8] = [<:i for let i in TABLE];
        }
    }
}